<html>
  <head>
        <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="ie=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="author" content="">
<meta name="description" content="TL;DR ¶ Go has now standardised iterators. Iterators are powerful. Being functions under the hood, iterators can be closures. The classification of iterators suggested by the documentation is ambiguous. Dividing iterators into two categories, “pure” and “impure”, seems to me preferrable. Whether iterators should be designed as “pure” whenever possible is unclear. The advent of iterators in Go ¶ The iterator pattern was popularised by the classic “Gang of Four” book as
[providing] a way to access the elements of an aggregate object sequentially without exposing its underlying representation.
">
<meta name="keywords" content=", Go, iterator, terminology, performance, micro-optimisation">
<meta name="robots" content="noodp">
<meta name="theme-color" content="#252627">
<link rel="canonical" href="//jub0bs.com/posts/2025-05-29-pure-vs-impure-iterators-in-go/">


    <title>
        
            Pure vs. impure iterators in Go :: jub0bs.com 
        
    </title>





<link rel="stylesheet" href="/main.dede02da9537a98158079c023e83573e18127834838ef08172acce888341a797.css">







  <meta itemprop="name" content="Pure vs. impure iterators in Go">
  <meta itemprop="description" content="TL;DR ¶ Go has now standardised iterators. Iterators are powerful. Being functions under the hood, iterators can be closures. The classification of iterators suggested by the documentation is ambiguous. Dividing iterators into two categories, “pure” and “impure”, seems to me preferrable. Whether iterators should be designed as “pure” whenever possible is unclear. The advent of iterators in Go ¶ The iterator pattern was popularised by the classic “Gang of Four” book as
[providing] a way to access the elements of an aggregate object sequentially without exposing its underlying representation.">
  <meta itemprop="datePublished" content="2025-05-29T07:00:00+00:00">
  <meta itemprop="dateModified" content="2025-05-29T07:00:00+00:00">
  <meta itemprop="wordCount" content="3193">
  <meta itemprop="keywords" content="Go,Iterator,Terminology,Performance,Micro-Optimisation">

  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Pure vs. impure iterators in Go">
  <meta name="twitter:description" content="TL;DR ¶ Go has now standardised iterators. Iterators are powerful. Being functions under the hood, iterators can be closures. The classification of iterators suggested by the documentation is ambiguous. Dividing iterators into two categories, “pure” and “impure”, seems to me preferrable. Whether iterators should be designed as “pure” whenever possible is unclear. The advent of iterators in Go ¶ The iterator pattern was popularised by the classic “Gang of Four” book as
[providing] a way to access the elements of an aggregate object sequentially without exposing its underlying representation.">







    <meta property="article:published_time" content="2025-05-29 07:00:00 +0000 UTC">








    </head>
</html>
